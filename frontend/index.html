<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D GAME WLA ZBI</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babylonjs/5.57.1/babylon.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            background: #1a1a2e;
            overflow: hidden;
        }
        #header {
            background: #16213e;
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #playerScore, #aiScore {
            font-size: 32px;
            font-weight: bold;
        }
        .score-label {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 5px;
        }
        #title {
            text-align: center;
        }
        #title h1 {
            font-size: 24px;
            margin-bottom: 5px;
        }
        #title p {
            font-size: 12px;
            color: #aaa;
        }
        #renderCanvas {
            width: 100%;
            height: calc(100vh - 80px);
            display: block;
            outline: none;
        }
        .player-color {
            color: #3b82f6;
        }
        .ai-color {
            color: #ef4444;
        }
    </style>
</head>
<body>
    <div id="header">
        <div>
            <div class="score-label">PLAYER</div>
            <div id="playerScore" class="player-color">0</div>
        </div>
        <div id="title">
            <h1>3D WLA ZBI</h1>
            <p>Use Arrow Keys or A/D to move</p>
        </div>
        <div>
            <div class="score-label">AI</div>
            <div id="aiScore" class="ai-color">0</div>
        </div>
    </div>
    <canvas id="renderCanvas"></canvas>

    <script>
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true);

        const createScene = () => {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.1, 0.1, 0.15);

            // Camera
            const camera = new BABYLON.ArcRotateCamera(
                "camera",
                Math.PI / 2,
                Math.PI / 3,
                30,
                new BABYLON.Vector3(0, 0, 0),
                scene
            );
            camera.attachControl(canvas, true);

            // Lights
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.8;

            // Game boundaries
            const fieldWidth = 20;
            const fieldDepth = 30;

            // Field
            const field = BABYLON.MeshBuilder.CreateGround("field", { width: fieldWidth, height: fieldDepth }, scene);
            const fieldMat = new BABYLON.StandardMaterial("fieldMat", scene);
            fieldMat.diffuseColor = new BABYLON.Color3(0.1, 0.3, 0.2);
            fieldMat.emissiveColor = new BABYLON.Color3(0.05, 0.15, 0.1);
            field.material = fieldMat;

            // Walls
            const wallMat = new BABYLON.StandardMaterial("wallMat", scene);
            wallMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.4);
            wallMat.alpha = 0.3;

            const leftWall = BABYLON.MeshBuilder.CreateBox("leftWall", { width: 0.5, height: 3, depth: fieldDepth }, scene);
            leftWall.position.x = -fieldWidth / 2;
            leftWall.position.y = 1.5;
            leftWall.material = wallMat;

            const rightWall = BABYLON.MeshBuilder.CreateBox("rightWall", { width: 0.5, height: 3, depth: fieldDepth }, scene);
            rightWall.position.x = fieldWidth / 2;
            rightWall.position.y = 1.5;
            rightWall.material = wallMat;

            // Ball
            const ball = BABYLON.MeshBuilder.CreateSphere("ball", { diameter: 0.8 }, scene);
            const ballMat = new BABYLON.StandardMaterial("ballMat", scene);
            ballMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
            ballMat.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            ball.material = ballMat;
            ball.position.y = 0.4;

            // Player paddle (blue)
            const player = BABYLON.MeshBuilder.CreateBox("player", { width: 4, height: 0.8, depth: 0.8 }, scene);
            const playerMat = new BABYLON.StandardMaterial("playerMat", scene);
            playerMat.diffuseColor = new BABYLON.Color3(0.2, 0.6, 1);
            playerMat.emissiveColor = new BABYLON.Color3(0.1, 0.3, 0.5);
            player.material = playerMat;
            player.position.z = fieldDepth / 2 - 1;
            player.position.y = 0.4;

            // AI paddle (red)
            const ai = BABYLON.MeshBuilder.CreateBox("ai", { width: 4, height: 0.8, depth: 0.8 }, scene);
            const aiMat = new BABYLON.StandardMaterial("aiMat", scene);
            aiMat.diffuseColor = new BABYLON.Color3(1, 0.3, 0.3);
            aiMat.emissiveColor = new BABYLON.Color3(0.5, 0.1, 0.1);
            ai.material = aiMat;
            ai.position.z = -fieldDepth / 2 + 1;
            ai.position.y = 0.4;

            // Game state
            let ballVelocity = { x: 0.15, z: -0.15 };
            let playerScore = 0;
            let aiScore = 0;
            let keys = {};

            // Keyboard input
            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;
            });

            window.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });

            // Reset ball
            const resetBall = (scoredBy) => {
                ball.position.x = 0;
                ball.position.z = 0;
                const speed = 0.15;
                ballVelocity.x = (Math.random() - 0.5) * speed * 2;
                ballVelocity.z = scoredBy === 'player' ? -speed : speed;
                
                if (scoredBy === 'player') {
                    playerScore++;
                    document.getElementById('playerScore').textContent = playerScore;
                } else {
                    aiScore++;
                    document.getElementById('aiScore').textContent = aiScore;
                }
            };

            // Game loop
            scene.onBeforeRenderObservable.add(() => {
                // Player movement
                const speed = 0.3;
                if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                    player.position.x -= speed;
                }
                if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                    player.position.x += speed;
                }

                // Keep player in bounds
                player.position.x = Math.max(-fieldWidth / 2 + 2, Math.min(fieldWidth / 2 - 2, player.position.x));

                // AI movement (simple follow)
                const aiSpeed = 0.2;
                if (ball.position.x < ai.position.x) {
                    ai.position.x -= aiSpeed;
                } else if (ball.position.x > ai.position.x) {
                    ai.position.x += aiSpeed;
                }
                ai.position.x = Math.max(-fieldWidth / 2 + 2, Math.min(fieldWidth / 2 - 2, ai.position.x));

                // Ball movement
                ball.position.x += ballVelocity.x;
                ball.position.z += ballVelocity.z;

                // Ball collision with walls
                if (ball.position.x <= -fieldWidth / 2 + 0.4 || ball.position.x >= fieldWidth / 2 - 0.4) {
                    ballVelocity.x *= -1;
                }

                // Ball collision with paddles
                const ballRadius = 0.4;
                
                // Player paddle collision
                if (ball.position.z >= player.position.z - 0.4 - ballRadius &&
                    ball.position.z <= player.position.z + 0.4 + ballRadius &&
                    Math.abs(ball.position.x - player.position.x) < 2 + ballRadius) {
                    ballVelocity.z = -Math.abs(ballVelocity.z);
                    ballVelocity.x += (ball.position.x - player.position.x) * 0.05;
                    ballVelocity.x = Math.max(-0.3, Math.min(0.3, ballVelocity.x));
                }

                // AI paddle collision
                if (ball.position.z <= ai.position.z + 0.4 + ballRadius &&
                    ball.position.z >= ai.position.z - 0.4 - ballRadius &&
                    Math.abs(ball.position.x - ai.position.x) < 2 + ballRadius) {
                    ballVelocity.z = Math.abs(ballVelocity.z);
                    ballVelocity.x += (ball.position.x - ai.position.x) * 0.05;
                    ballVelocity.x = Math.max(-0.3, Math.min(0.3, ballVelocity.x));
                }

                // Score detection
                if (ball.position.z > fieldDepth / 2) {
                    resetBall('ai');
                } else if (ball.position.z < -fieldDepth / 2) {
                    resetBall('player');
                }
            });

            return scene;
        };

        const scene = createScene();

        engine.runRenderLoop(() => {
            scene.render();
        });

        window.addEventListener('resize', () => {
            engine.resize();
        });
    </script>
</body>
</html>
